<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>python装饰器详解 | Just For Fun</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="之前用python简单写了一下斐波那契数列的递归实现（如下），发现运行速度很慢。
def fib_direct(n):
    assert n &amp;gt; 0, &amp;apos;invalid n&amp;apos;
    if n &amp;lt; 3:
        return n
    else:
        return fib_direct(n - 1) + fib_direct(n - 2)">
<meta property="og:type" content="article">
<meta property="og:title" content="python装饰器详解">
<meta property="og:url" content="http://selfboot.cn/2014/08/10/python_decorator/index.html">
<meta property="og:site_name" content="Just For Fun">
<meta property="og:description" content="之前用python简单写了一下斐波那契数列的递归实现（如下），发现运行速度很慢。
def fib_direct(n):
    assert n &amp;gt; 0, &amp;apos;invalid n&amp;apos;
    if n &amp;lt; 3:
        return n
    else:
        return fib_direct(n - 1) + fib_direct(n - 2)">
<meta property="og:image" content="http://xuelangzf-github.qiniudn.com/20140810_recursion_without_cache.png">
<meta property="og:updated_time" content="2015-10-27T13:46:34.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="python装饰器详解">
<meta name="twitter:description" content="之前用python简单写了一下斐波那契数列的递归实现（如下），发现运行速度很慢。
def fib_direct(n):
    assert n &amp;gt; 0, &amp;apos;invalid n&amp;apos;
    if n &amp;lt; 3:
        return n
    else:
        return fib_direct(n - 1) + fib_direct(n - 2)">
<meta name="twitter:image" content="http://xuelangzf-github.qiniudn.com/20140810_recursion_without_cache.png">
  
    <link rel="alternative" href="/atom.xml" title="Just For Fun" type="application/atom+xml">
  
  
    <link rel="icon" href="/image/favicon.ico">
  
  <link href="//fonts.useso.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link href="//libs.useso.com/js/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-41784041-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
<!-- Baidu Analytics -->
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?fd3ab4b3c488cbb43afa1c2669f06648";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<!-- End Baidu Analytics -->


</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Just For Fun</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">享受快乐的时光</a>
        </h2>
      
    </div>
    <div id="header-menu">
      <nav id="main-nav">
        <ul>
        
          <li><a href="/"><i class="fa fa-home icon-setting"></i></a></li>
        
          <li><a href="/archives"><i class="fa fa-archive icon-setting"></i></a></li>
        
          <li><a href="/aboutme.html"><i class="fa fa-user icon-setting"></i></a></li>
        
        
          <li><a href="/atom.xml"><i class="fa fa-rss %> icon-setting"></i></a></li>
        
        </ul>
      </nav>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-python_decorator" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/08/10/python_decorator/" class="article-date">
  <time datetime="2014-08-09T16:00:00.000Z" itemprop="datePublished">8月 10 2014</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/程序设计/">程序设计</a>
  </div>

  </div>
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      python装饰器详解
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前用python简单写了一下斐波那契数列的递归实现（如下），发现运行速度很慢。</p>
<pre><code>def fib_direct(n):
    assert n &gt; 0, &apos;invalid n&apos;
    if n &lt; 3:
        return n
    else:
        return fib_direct(n - 1) + fib_direct(n - 2)
</code></pre><p>然后大致分析了一下fib_direct(5)的递归调用过程，如下图：</p>
<p><img src="http://xuelangzf-github.qiniudn.com/20140810_recursion_without_cache.png" alt="递归调用" title="递归调用"></p>
<p>可以看到多次<a href="id:recursive" target="_blank" rel="external">重复调用</a>，因此效率十分低。进一步，可以算出递归算法的<code>时间复杂度</code>。T(n) = T(n-1) + T(n-2)，用常系数线性齐次递推方程的解法，解出递推方程的特征根，特征根里最大的n次方就是它的时间复杂度O(1.618^n)，指数级增长。</p>
<p>为了避免重复调用，可以适当地做缓存，python的装饰器可以完美的完成这一任务。</p>
<a id="more"></a>
<h1 id="装饰器：基础"><a href="#装饰器：基础" class="headerlink" title="装饰器：基础"></a>装饰器：基础</h1><p><strong>python中一切都是对象，这里需要强调<a href="id:func_is_obj" target="_blank" rel="external"><code>函数是对象</code></a>。</strong>为了更好地理解函数也是对象，下面结合代码片段来说明这一点。</p>
<pre><code>def shout(word=&quot;yes&quot;):
    return word.capitalize() + &quot;!&quot;

print shout()
# outputs: Yes!

&quot;&quot;&quot;
As an object, you can assign the function to a variable like any other object.
Notice we don&apos;t use parentheses: we are not calling the function,
we are putting the function &quot;shout&quot; into the variable &quot;scream&quot;.
&quot;&quot;&quot;
scream = shout

print scream()
# outputs: Yes!

&quot;&quot;&quot;
More than that, it means you can remove the old name &apos;shout&apos;,
and the function will still be accessible from &apos;scream&apos;.
&quot;&quot;&quot;
del shout
try:
    print shout()
except NameError, e:
    print e
    # outputs: name &apos;shout&apos; is not defined

print scream()
# outputs: &apos;Yes!&apos;
</code></pre><p>因为<a href="#func_is_obj">函数是对象</a>，所以python中函数还有一个有趣的特性：<a href="id:func_in_func" target="_blank" rel="external"><code>函数可以被定义在另一个函数中</code></a>。下面来看一个简单的例子。</p>
<pre><code>def talk():

    # You can define a function on the fly in &quot;talk&quot;
    def whisper(word=&quot;yes&quot;):
        return word.lower()+&quot;...&quot;
    print whisper()

&quot;&quot;&quot;
You call &quot;talk&quot;, that defines &quot;whisper&quot; EVERY TIME you call it,
then &quot;whisper&quot; is called in &quot;talk&quot;.
&quot;&quot;&quot;
talk()
# outputs: yes...

# But &quot;whisper&quot; DOES NOT EXIST outside &quot;talk&quot;.
try:
    print whisper()
except NameError, e:
    print e
    # outputs : name &apos;whisper&apos; is not defined
</code></pre><h2 id="函数引用"><a href="#函数引用" class="headerlink" title="函数引用"></a>函数引用</h2><p><a href="#func_is_obj">前面</a>已经知道函数是对象。那么：</p>
<ol>
<li>可以被赋给另一个变量</li>
<li>可以被定义在另一个函数里</li>
</ol>
<p>这也意味着，<code>一个函数可以返回另一个函数</code>，下面看一个简单的例子。</p>
<pre><code>def get_talk(kind=&quot;shout&quot;):

    def whisper(word=&quot;yes&quot;):
        return word.lower() + &quot;...&quot;

    def shout(word=&quot;yes&quot;):
        return word.capitalize() + &quot;!&quot;

    return whisper if kind == &quot;whisper&quot; else shout

# Get the function and assign it to a variable
talk = get_talk()

# You can see that &quot;talk&quot; is here a function object:
print talk
# outputs : &lt;function shout at 0x107ae9578&gt;

print talk()
# outputs : Yes!

# And you can even use it directly if you feel wild:
print get_talk(&quot;whisper&quot;)()
# outputs : yes...
</code></pre><p>我们来进一步挖掘一下函数的特性，既然可以<code>返回函数</code>，那么我们也可以把<code>函数作为参数传递</code>。</p>
<pre><code>def whisper(word=&quot;yes&quot;):
    return word.lower() + &quot;...&quot;


def do_something_before(func):
    print &quot;I do something before.&quot;
    print &quot;Now the function you gave me:\n&quot;, func()

do_something_before(whisper)
&quot;&quot;&quot;outputs
I do something before.
Now the function you gave me:
yes...
&quot;&quot;&quot;
</code></pre><p>现在，了解装饰器所需要的所有要点我们已经掌握了，通过上面的例子，我们还可以看出，装饰器其实就是<code>封装器</code>，可以让我们在不修改原函数的基础上，在执行原函数的前后执行别的代码。</p>
<h1 id="手工装饰器"><a href="#手工装饰器" class="headerlink" title="手工装饰器"></a>手工装饰器</h1><p>下面我们<a href="id:handcrafted_decorator" target="_blank" rel="external">手工实现一个简单的装饰器</a>。</p>
<pre><code>def my_shiny_new_decorator(a_function_to_decorate):

    &quot;&quot;&quot;
    Inside, the decorator defines a function on the fly: the wrapper.
    This function is going to be wrapped around the original function
    so it can execute code before and after it.
    &quot;&quot;&quot;
    def the_wrapper_around_the_original_function():

        &quot;&quot;&quot;
        Put here the code you want to be executed BEFORE the original
        function is called
        &quot;&quot;&quot;
        print &quot;Before the function runs&quot;

        # Call the function here (using parentheses)
        a_function_to_decorate()

        &quot;&quot;&quot;
        Put here the code you want to be executed AFTER the original
        function is called
        &quot;&quot;&quot;
        print &quot;After the function runs&quot;

    &quot;&quot;&quot;
    At this point, &quot;a_function_to_decorate&quot; HAS NEVER BEEN EXECUTED.
    We return the wrapper function we have just created.
    The wrapper contains the function and the code to execute before
    and after. It’s ready to use!
    &quot;&quot;&quot;
    return the_wrapper_around_the_original_function


# Now imagine you create a function you don&apos;t want to ever touch again.
def a_stand_alone_function():
    print &quot;I am a stand alone function, don&apos;t you dare modify me&quot;

a_stand_alone_function()
# outputs: I am a stand alone function, don&apos;t you dare modify me

&quot;&quot;&quot;
Well, you can decorate it to extend its behavior.
Just pass it to the decorator, it will wrap it dynamically in
any code you want and return you a new function ready to be used:
&quot;&quot;&quot;

a_stand_alone_function_decorated = my_shiny_new_decorator(a_stand_alone_function)
a_stand_alone_function_decorated()
&quot;&quot;&quot;outputs:
Before the function runs
I am a stand alone function, don&apos;t you dare modify me
After the function runs
&quot;&quot;&quot;
</code></pre><p>现在，如果我们想每次调用<code>a_stand_alone_function</code>的时候，实际上调用的是封装后的函数<code>a_stand_alone_function_decorated</code>，那么只需要用a_stand_alone_function去覆盖my_shiny_new_decorator返回的函数即可。也就是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a_stand_alone_function = my_shiny_new_decorator(a_stand_alone_function)</div></pre></td></tr></table></figure>
<h1 id="装饰器阐述"><a href="#装饰器阐述" class="headerlink" title="装饰器阐述"></a>装饰器阐述</h1><p>对于<a href="#handcrafted_decorator">前面的例子</a>，如果用装饰器语法，可以添加如下：</p>
<pre><code>@my_shiny_new_decorator
def another_stand_alone_function():
    print &quot;Leave me alone&quot;

another_stand_alone_function()
&quot;&quot;&quot;outputs:
Before the function runs
Leave me alone
After the function runs
&quot;&quot;&quot;
</code></pre><p>对了，这就是装饰器语法，这里的<code>@my_shiny_new_decorator</code>是<code>another_stand_alone_function = my_shiny_new_decorator(another_stand_alone_function)</code>的简写。</p>
<p>装饰器只是<a href="http://en.wikipedia.org/wiki/Decorator_pattern" target="_blank" rel="external">装饰器设计模式</a>的python实现，python还存在其他几个经典的设计模式，以方便开发，例如迭代器iterators。</p>
<p>当然了，我们也可以嵌套装饰器。</p>
<pre><code>def bread(func):
    def wrapper():
        print &quot;&lt;/&apos;&apos;&apos;&apos;&apos;&apos;\&gt;&quot;
        func()
        print &quot;&lt;\______/&gt;&quot;

    return wrapper


def ingredients(func):
    def wrapper():
        print &quot;#tomatoes#&quot;
        func()
        print &quot;~salad~&quot;

    return wrapper


def sandwich(food=&quot;--ham--&quot;):
    print food

sandwich()
# outputs: --ham--
sandwich = bread(ingredients(sandwich))
sandwich()
&quot;&quot;&quot;outputs:
&lt;/&apos;&apos;&apos;&apos;&apos;&apos;\&gt;
 #tomatoes#
 --ham--
 ~salad~
&lt;\______/&gt;
&quot;&quot;&quot;
</code></pre><p>用python的装饰器语法，如下：</p>
<pre><code>@bread
@ingredients
def sandwich_2(food=&quot;--ham_2--&quot;):
    print food

sandwich_2()
</code></pre><p>放置装饰器的位置很关键。</p>
<pre><code>@ingredients
@bread
def strange_sandwich(food=&quot;--ham--&quot;):
    print food

strange_sandwich()
&quot;&quot;&quot;outputs:
#tomatoes#
&lt;/&apos;&apos;&apos;&apos;&apos;&apos;\&gt;
 --ham--
&lt;\______/&gt;
 ~salad~
&quot;&quot;&quot;
</code></pre><h1 id="装饰器高级用法"><a href="#装饰器高级用法" class="headerlink" title="装饰器高级用法"></a>装饰器高级用法</h1><h2 id="给装饰器函数传递参数"><a href="#给装饰器函数传递参数" class="headerlink" title="给装饰器函数传递参数"></a>给装饰器函数传递参数</h2><p><strong>当我们调用装饰器返回的函数时，其实是在调用封装函数，给封装函数传递参数也就同样的给被装饰函数传递了参数。</strong></p>
<pre><code>def a_decorator_passing_arguments(function_to_decorate):
    def a_wrapper_accepting_arguments(arg1, arg2):
        print &quot;I got args! Look:&quot;, arg1, arg2
        function_to_decorate(arg1, arg2)
    return a_wrapper_accepting_arguments

&quot;&quot;&quot;
Since when you are calling the function returned by the decorator, you are
calling the wrapper, passing arguments to the wrapper will let it pass them to
the decorated function
&quot;&quot;&quot;


@a_decorator_passing_arguments
def print_full_name(first_name, last_name):
    print &quot;My name is&quot;, first_name, last_name


print_full_name(&quot;Peter&quot;, &quot;Venkman&quot;)
&quot;&quot;&quot;outputs:
I got args! Look: Peter Venkman
My name is Peter Venkman
&quot;&quot;&quot;
</code></pre><h2 id="装饰方法"><a href="#装饰方法" class="headerlink" title="装饰方法"></a>装饰方法</h2><p>python中函数和方法几乎一样，除了方法中第一个参数是指向当前对象的引用(self)。这意味着我们可以为方法创建装饰器，只是要记得考虑self。</p>
<pre><code>def method_friendly_decorator(method_to_decorate):
    def wrapper(self, lie):
        lie = lie - 3
        return method_to_decorate(self, lie)
    return wrapper


class Lucy(object):

    def __init__(self):
        self.age = 32

    @method_friendly_decorator
    def sayYourAge(self, lie):
        print &quot;I am %s, what did you think?&quot; % (self.age + lie)

l = Lucy()
l.sayYourAge(-3)
# outputs: I am 26, what did you think?
</code></pre><p>我们还可以创建一个通用的装饰器，可以用于所有的方法或者函数，而且不用考虑它的参数情况。这时候，我们要用到<code>*args, **kwargs</code>。</p>
<pre><code>def a_decorator_passing_arbitrary_arguments(function_to_decorate):
    # The wrapper accepts any arguments
    def a_wrapper_accepting_arbitrary_arguments(*args, **kwargs):
        print &quot;Do I have args?:&quot;
        print args
        print kwargs
        # Then you unpack the arguments, here *args, **kwargs
        # If you are not familiar with unpacking, check:
        # http://www.saltycrane.com/blog/2008/01/how-to-use-args-and-kwargs-in-python/
        function_to_decorate(*args, **kwargs)
    return a_wrapper_accepting_arbitrary_arguments
</code></pre><p>另外还有一些高级用法，这里不做详细说明，可以在<a href="https://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python" target="_blank" rel="external">How can I make a chain of function decorators in Python?</a>进一步深入了解装饰器。</p>
<h1 id="functools-wraps"><a href="#functools-wraps" class="headerlink" title="functools.wraps"></a>functools.wraps</h1><p>装饰器封装了函数，这使得调试函数变得困难。不过在python 2.5引入了<code>functools</code>模块，它包含了<code>functools.wraps()</code>函数，这个函数可以将被封装函数的名称、模块、文档拷贝给封装函数。有趣的是，functools.wraps是一个装饰器。为了更好地理解，看以下代码：</p>
<pre><code># For debugging, the stacktrace prints you the function __name__
def foo():
    print &quot;foo&quot;

print foo.__name__
# outputs: foo


def bar(func):
    def wrapper():
        print &quot;bar&quot;
        return func()
    return wrapper


@bar
def foo():
    print &quot;foo&quot;

print foo.__name__
# outputs: wrapper


import functools


def bar(func):
    # We say that &quot;wrapper&quot;, is wrapping &quot;func&quot;
    # and the magic begins
    @functools.wraps(func)
    def wrapper():
        print &quot;bar&quot;
        return func()
    return wrapper


@bar
def foo():
    print &quot;foo&quot;

print foo.__name__
# outputs: foo
</code></pre><h1 id="为何装饰器那么有用"><a href="#为何装饰器那么有用" class="headerlink" title="为何装饰器那么有用"></a>为何装饰器那么有用</h1><p>让我们回到本篇文章开始的<a href="#recursive">问题</a>上，重复调用导致递归的效率低下，因此考虑使用缓存机制，空间换时间。这里，就可以使用装饰器做缓存，看下面代码：</p>
<pre><code>from functools import wraps

def cache(func):
    caches = {}

    @wraps(func)
    def wrap(*args):
        if args not in caches:
            caches[args] = func(*args)

        return caches[args]
    return wrap


@cache
def fib_cache(n):
    assert n &gt; 0, &apos;invalid n&apos;
    if n &lt; 3:
        return 1
    else:
        return fib_cache(n - 1) + fib_cache(n - 2)
</code></pre><p>这样递归中就不会重复调用，效率也会提高很多。具体可以看<a href="https://gist.github.com/xuelangZF/99f59f1b4cf8fb8c08eb" target="_blank" rel="external">这里</a>，从执行时间很容易看出做了缓存之后速度有了很大的提升。装饰器还可以用来扩展外部接口函数(通常你不能修改它)的功能，或者用来调试函数。其实，装饰器可以用于各种各样的场合！</p>
<p>python本身提供了一些装饰器：property,staticmethod，等等。另外，Django使用装饰器去管理缓存和权限。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.gocalf.com/blog/calc-fibonacci.html" target="_blank" rel="external">计算斐波纳契数，分析算法复杂度</a><br><a href="https://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python" target="_blank" rel="external">How can I make a chain of function decorators in Python?</a><br><a href="http://www.cnblogs.com/huxi/archive/2011/03/01/1967600.html" target="_blank" rel="external">Python装饰器与面向切面编程</a><br><a href="http://www.saltycrane.com/blog/2008/01/how-to-use-args-and-kwargs-in-python/" target="_blank" rel="external">how to use args and kwargs in python?</a><br><a href="http://martin-thoma.com/fibonacci-recursion-decorators/" target="_blank" rel="external">Fibonacci, recursion and decorators</a>  </p>

      
    </div>

    
	    <!-- 添加捐赠图标 -->
<div class ="post-donate">
    <div id="donate_board" class="donate_bar center">
        <a id="btn_donate" class="btn_donate" href="javascript:;" title="打赏"></a>
        <span class="donate_txt">
           &uarr;<br>
		   欣赏此文？支持一下吧
        </span>
        <br>
      </div>  
	<div id="donate_guide" class="donate_bar center hidden" >
		<!-- 支付宝打赏图案 -->
		<img src="http://xuelangzf-github.qiniudn.com/zhifubao.jpg" alt="支付宝打赏"> 
		<!-- 微信打赏图案 -->
		<img src="http://xuelangzf-github.qiniudn.com/weixin.jpg" alt="微信打赏">  
    </div>
	<script type="text/javascript">
		document.getElementById('btn_donate').onclick = function(){
			$('#donate_board').addClass('hidden');
			$('#donate_guide').removeClass('hidden');
		}
	</script>
</div>
<!-- 添加捐赠图标 -->

    
  
    
	    <div class="article-footer-copyright">

<p>本文由 selfboot 发表于 <a href="http://selfboot.cn" target="_blank">个人博客</a>，采用<a href="http://creativecommons.org/licenses/by-sa/3.0/cn" target="_blank" >署名-非商业性使用-相同方式共享 3.0 中国大陆许可协议</a>。</p>
<p>非商业转载请注明作者及出处。商业转载请联系<a href="mailto:xuezaigds@gmail.com">作者</a>本人。</p>
<p>
本文标题为: python装饰器详解<br/>
本文链接为: <a href="/2014/08/10/python_decorator/" target="_blank">http://selfboot.cn/2014/08/10/python_decorator/</a>
</p>
</div>

    

    <footer class="article-footer">
      
        <a href="http://selfboot.cn/2014/08/10/python_decorator/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2014/08/12/python_how_to_use_trie_tree/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          大展身手的字典树
        
      </div>
    </a>
  
  
    <a href="/2014/08/08/python_copy/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">操作之灵魂——拷贝</div>
    </a>
  
</nav>

  
</article>


<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>



  <!-- Go to www.addthis.com/dashboard to customize your tools -->
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-57adc438b914651b"></script>



</section>
      </div>
    </div>
    
    
<script>
  var disqus_shortname = 'xuelangZF';
  
  var disqus_url = 'http://selfboot.cn/2014/08/10/python_decorator/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  }());
</script>


<script src="http://libs.useso.com/js/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/script.js"></script>

  </div>
</body>
</html>
